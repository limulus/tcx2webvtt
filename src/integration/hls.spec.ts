import Hls from 'hls.js'
import { test, expect } from 'vitest'

import { BrowserHLSSegmenter, HLSSegment } from './hls-browser-helper.js'
import { SequentialCueGenerator } from '../lib/sequential-cue-generator.js'
import { TCXReader } from '../lib/tcx-reader.js'

/**
 * This test file verifies that the HLS output generated by our library
 * works correctly with HLS.js for browser compatibility.
 */

async function createHLSFromTCX(tcxData: string, segmentDuration = 10000) {
  const tcxReader = new TCXReader(tcxData)
  const samples = tcxReader.getSamples()

  // Limit to first 25 samples for faster tests
  const limitedSamples = samples.slice(0, 25)

  const cueGenerator = new SequentialCueGenerator()
  const cues = cueGenerator.generateCues(limitedSamples)

  const hlsSegmenter = new BrowserHLSSegmenter(segmentDuration)

  // Use the public methods to generate segments and playlist without filesystem
  const segments = hlsSegmenter.segmentCues(cues)
  const playlist = hlsSegmenter.generatePlaylist(segments)

  // Create a file map for browser consumption
  const fileMap = new Map<string, string>()
  fileMap.set('index.m3u8', playlist)

  segments.forEach((segment: HLSSegment) => {
    fileMap.set(segment.filename, segment.content)
  })

  return { fileMap, cues, samples: limitedSamples, segments }
}

function createBlobUrls(fileMap: Map<string, string>) {
  const urlMap = new Map<string, string>()

  for (const [filename, content] of fileMap.entries()) {
    const mimeType = filename.endsWith('.m3u8')
      ? 'application/vnd.apple.mpegurl'
      : 'text/vtt'
    const blob = new Blob([content], { type: mimeType })
    const url = URL.createObjectURL(blob)
    urlMap.set(filename, url)
  }

  return urlMap
}

test('HLS.js should load and parse HLS playlist with WebVTT subtitle segments', async () => {
  if (!Hls.isSupported()) {
    console.warn('HLS.js is not supported in this environment, skipping test')
    return
  }

  const tcxData = await fetch('/fixtures/tcx/healthkit-cycling.tcx').then((res) =>
    res.text()
  )
  const { fileMap } = await createHLSFromTCX(tcxData, 10000) // 10-second segments

  expect(fileMap.has('index.m3u8')).toBe(true)
  expect(fileMap.size).toBeGreaterThan(1) // Should have playlist + segments

  const urlMap = createBlobUrls(fileMap)

  // Modify subtitle playlist to use blob URLs for segments
  const originalPlaylist = fileMap.get('index.m3u8')!
  const modifiedSubtitlePlaylist = originalPlaylist.replace(
    /fileSequence\d+\.webvtt/g,
    (match) => urlMap.get(match) ?? match
  )

  // Create subtitle playlist blob
  const subtitlePlaylistBlob = new Blob([modifiedSubtitlePlaylist], {
    type: 'application/vnd.apple.mpegurl',
  })
  const subtitlePlaylistUrl = URL.createObjectURL(subtitlePlaylistBlob)

  // Create master playlist that references the subtitle playlist
  const hlsSegmenter = new BrowserHLSSegmenter()
  const masterPlaylist = hlsSegmenter.generateMasterPlaylist(subtitlePlaylistUrl)
  const masterPlaylistBlob = new Blob([masterPlaylist], {
    type: 'application/vnd.apple.mpegurl',
  })
  const finalPlaylistUrl = URL.createObjectURL(masterPlaylistBlob)

  // Create video element
  const video = document.createElement('video')
  video.setAttribute('data-testid', 'hls-video')
  document.body.appendChild(video)

  try {
    // Initialize HLS.js
    const hls = new Hls({
      debug: false,
      enableWorker: false, // Disable worker for test environment
    })

    // Load the playlist
    hls.loadSource(finalPlaylistUrl)
    hls.attachMedia(video)

    // Wait for manifest to load
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('HLS manifest load timed out'))
      }, 5000)

      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        clearTimeout(timeout)
        resolve()
      })

      hls.on(Hls.Events.ERROR, (_event, data) => {
        clearTimeout(timeout)
        reject(new Error(`HLS error: ${data.type} - ${data.details}`))
      })
    })

    // Verify that subtitle tracks are available
    expect(hls.subtitleTracks).toBeDefined()
    expect(hls.subtitleTracks.length).toBeGreaterThan(0)

    const subtitleTrack = hls.subtitleTracks[0]
    expect(subtitleTrack.type).toBe('SUBTITLES')
    expect(subtitleTrack.url).toBeDefined()

    // Enable the subtitle track
    hls.subtitleTrack = 0

    // Wait for subtitle track to load
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Subtitle track load timed out'))
      }, 3000)

      hls.on(Hls.Events.SUBTITLE_TRACK_LOADED, () => {
        clearTimeout(timeout)
        resolve()
      })
    })

    // Clean up
    hls.destroy()
  } finally {
    // Clean up URLs and DOM
    for (const url of urlMap.values()) {
      URL.revokeObjectURL(url)
    }
    URL.revokeObjectURL(subtitlePlaylistUrl)
    URL.revokeObjectURL(finalPlaylistUrl)
    document.body.removeChild(video)
  }
})

test('HLS segments should contain expected WebVTT metadata structure', async () => {
  const tcxData = await fetch('/fixtures/tcx/healthkit-cycling.tcx').then((res) =>
    res.text()
  )
  const { fileMap, samples } = await createHLSFromTCX(tcxData, 10000)

  // Get the first segment
  const firstSegmentName = Array.from(fileMap.keys()).find((name) =>
    name.startsWith('fileSequence0')
  )!
  const firstSegmentContent = fileMap.get(firstSegmentName)!

  expect(firstSegmentContent).toContain('WEBVTT')
  expect(firstSegmentContent).toContain('X-TIMESTAMP-MAP=MPEGTS:900000,LOCAL:00:00:00.000')

  // Verify the content has proper timing format
  expect(firstSegmentContent).toMatch(
    /\d{2}:\d{2}:\d{2}\.\d{3} --> \d{2}:\d{2}:\d{2}\.\d{3}/
  )

  // Verify JSON metadata is present
  expect(firstSegmentContent).toMatch(/\[.*"metric".*"value".*\]/)

  // Parse and verify the JSON structure
  const jsonMatches = firstSegmentContent.match(/\[.*?\]/g)
  expect(jsonMatches).toBeTruthy()

  if (jsonMatches) {
    const firstJson = JSON.parse(jsonMatches[0])
    expect(Array.isArray(firstJson)).toBe(true)
    expect(firstJson[0]).toHaveProperty('metric')
    expect(firstJson[0]).toHaveProperty('value')

    // Verify metric matches our sample data
    const firstSample = samples[0]
    expect(firstJson[0].metric).toBe(firstSample.metric)
    expect(firstJson[0].value).toEqual(firstSample.value)
  }
})

test('HLS playlist should have correct format and timing', async () => {
  const tcxData = await fetch('/fixtures/tcx/healthkit-cycling.tcx').then((res) =>
    res.text()
  )
  const { fileMap } = await createHLSFromTCX(tcxData, 5000) // 5-second segments for more segments

  const playlist = fileMap.get('index.m3u8')!

  // Verify M3U8 format
  expect(playlist).toContain('#EXTM3U')
  expect(playlist).toContain('#EXT-X-VERSION:6')
  expect(playlist).toContain('#EXT-X-TARGETDURATION:')
  expect(playlist).toContain('#EXT-X-MEDIA-SEQUENCE:0')
  expect(playlist).toContain('#EXT-X-PLAYLIST-TYPE:VOD')
  expect(playlist).toContain('#EXT-X-ENDLIST')

  // Verify segment entries
  const segmentEntries = playlist.match(/#EXTINF:[\d.]+,\s*\n[\w.]+/g)
  expect(segmentEntries).toBeTruthy()
  expect(segmentEntries!.length).toBeGreaterThanOrEqual(3) // Should have at least 3 segments

  // Verify segment filenames match what's in our file map
  const segmentFilenames = playlist.match(/fileSequence\d+\.webvtt/g)
  expect(segmentFilenames).toBeTruthy()

  for (const filename of segmentFilenames!) {
    expect(fileMap.has(filename)).toBe(true)
  }
})

test('HLS should handle multiple segments correctly', async () => {
  const tcxData = await fetch('/fixtures/tcx/healthkit-cycling.tcx').then((res) =>
    res.text()
  )
  // Use small segments to force multiple segments
  const { fileMap } = await createHLSFromTCX(tcxData, 3000) // 3-second segments

  // Verify we actually created multiple segments
  const segmentFiles = Array.from(fileMap.keys()).filter((name) =>
    name.startsWith('fileSequence')
  )
  expect(segmentFiles.length).toBeGreaterThan(1)
  expect(segmentFiles.length).toBeGreaterThanOrEqual(3) // Should have at least 3 segments

  // Verify playlist references all segments
  const playlist = fileMap.get('index.m3u8')!
  segmentFiles.forEach((filename) => {
    expect(playlist).toContain(filename)
  })

  // Verify each segment has proper WebVTT structure
  segmentFiles.forEach((filename) => {
    const segmentContent = fileMap.get(filename)!
    expect(segmentContent).toContain('WEBVTT')
    expect(segmentContent).toContain('X-TIMESTAMP-MAP=MPEGTS:900000,LOCAL:00:00:00.000')

    // Each segment should have either cue content or be properly formatted empty
    expect(
      segmentContent.includes('"metric"') ||
        segmentContent === 'WEBVTT\nX-TIMESTAMP-MAP=MPEGTS:900000,LOCAL:00:00:00.000\n'
    ).toBe(true)
  })

  // Verify playlist format for multiple segments
  const segmentEntries = playlist.match(/#EXTINF:[\d.]+,\s*\n[\w.]+/g)
  expect(segmentEntries).toBeTruthy()
  expect(segmentEntries!.length).toBe(segmentFiles.length)

  // Verify durations are reasonable (each segment should be around 3 seconds or less)
  segmentEntries!.forEach((entry) => {
    const durationMatch = entry.match(/#EXTINF:([\d.]+),/)
    expect(durationMatch).toBeTruthy()
    const duration = parseFloat(durationMatch![1])
    expect(duration).toBeGreaterThan(0)
    expect(duration).toBeLessThanOrEqual(3.1) // Allow small buffer for segment boundaries
  })
})

test('HLS should handle seeking within segments correctly', async () => {
  if (!Hls.isSupported()) {
    console.warn('HLS.js is not supported in this environment, skipping test')
    return
  }

  const tcxData = await fetch('/fixtures/tcx/healthkit-cycling.tcx').then((res) =>
    res.text()
  )
  const { fileMap } = await createHLSFromTCX(tcxData, 8000) // 8-second segments

  const urlMap = createBlobUrls(fileMap)

  // Modify playlist to use blob URLs
  const originalPlaylist = fileMap.get('index.m3u8')!
  const modifiedPlaylist = originalPlaylist.replace(
    /fileSequence\d+\.webvtt/g,
    (match) => urlMap.get(match) ?? match
  )

  const finalPlaylistBlob = new Blob([modifiedPlaylist], {
    type: 'application/vnd.apple.mpegurl',
  })
  const finalPlaylistUrl = URL.createObjectURL(finalPlaylistBlob)

  const video = document.createElement('video')
  document.body.appendChild(video)

  try {
    const hls = new Hls({ debug: false, enableWorker: false })
    hls.loadSource(finalPlaylistUrl)
    hls.attachMedia(video)

    // Wait for manifest to load
    await new Promise<void>((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('Timeout'))
      }, 3000)
      hls.on(Hls.Events.MANIFEST_PARSED, () => {
        clearTimeout(timeout)
        resolve()
      })
    })

    // Verify we can get level details (segment information)
    expect(hls.levels).toBeDefined()
    expect(hls.levels.length).toBeGreaterThan(0)

    const level = hls.levels[0]
    expect(level.details).toBeDefined()
    expect(level.details!.fragments.length).toBeGreaterThan(0)

    // Verify fragment structure
    const firstFragment = level.details!.fragments[0]
    expect(firstFragment.duration).toBeGreaterThan(0)
    expect(firstFragment.url).toBeDefined()

    hls.destroy()
  } finally {
    for (const url of urlMap.values()) {
      URL.revokeObjectURL(url)
    }
    URL.revokeObjectURL(finalPlaylistUrl)
    document.body.removeChild(video)
  }
})
